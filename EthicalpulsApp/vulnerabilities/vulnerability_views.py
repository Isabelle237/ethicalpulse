from collections import Counter
from zapv2 import ZAPv2
from django.core.paginator import Paginator

import csv
import json
from pyexpat.errors import messages
import subprocess
import time

from django.http import JsonResponse
from django.shortcuts import redirect, render
from django.contrib.auth.decorators import login_required
from EthicalpulsApp.forms import ScanForm
from EthicalpulsApp.models import Project, Scan, Vulnerability
from EthicalpulsApp.views import  get_base_context
from django.http import HttpResponse
from django.shortcuts import get_object_or_404
from reportlab.lib.pagesizes import letter
from reportlab.platypus import SimpleDocTemplate, Paragraph, Spacer, PageBreak
from reportlab.lib.styles import getSampleStyleSheet, ParagraphStyle
from reportlab.lib import colors
from django.utils.timezone import now
from django.core.paginator import Paginator
from django.db.models import Q, Count
from django.contrib import messages
from datetime import datetime


def get_severity_class(severity):
    if severity == 'critical':
        return 'danger'
    elif severity == 'high':
        return 'warning text-dark'
    elif severity == 'medium':
        return 'primary'
    elif severity == 'low':
        return 'success'
    else:
        return 'secondary'

def get_status_class(status):
    if status == 'scheduled':
        return 'warning text-dark'
    elif status == 'in_progress':
        return 'primary'
    elif status == 'completed':
        return 'success'
    elif status == 'failed':
        return 'danger'
    else:
        return 'secondary'

def classify_scan_findings(scan_results):
    severity_map = {
        "critical": [],
        "high": [],
        "medium": [],
        "low": [],
        "info": []
    }

    def get_nmap_severity(service, port):
        critical_services = ['msrpc', 'rdp', 'telnet', 'vnc']
        high_services = ['ftp', 'smb', 'smtp']
        medium_services = ['http', 'ssh', 'mysql']
        low_services = ['https', 'dns']
        service = service.lower()
        if service in critical_services or port in [3389, 23, 5900]:
            return 'critical'
        elif service in high_services or port in [21, 445, 25]:
            return 'high'
        elif service in medium_services or port in [80, 22, 3306]:
            return 'medium'
        elif service in low_services or port in [443, 53]:
            return 'low'
        else:
            return 'info'

    def get_sqlmap_severity(vulnerability):
        """
        Détermine la sévérité en fonction des vulnérabilités SQLMap.
        """
        if "boolean-based blind" in vulnerability.lower():
            return 'high'
        elif "time-based blind" in vulnerability.lower():
            return 'medium'
        elif "error-based" in vulnerability.lower():
            return 'critical'
        else:
            return 'info'

    def get_zap_severity(risk):
        """
        Récupère directement la sévérité à partir des résultats ZAP.
        """
        risk = risk.lower()
        if risk == 'high':
            return 'critical'
        elif risk == 'medium':
            return 'high'
        elif risk == 'low':
            return 'medium'
        else:
            return 'info'

    # Parcourir les résultats des différents outils
    for tool, results in scan_results.items():
        for result in results:
            if tool == "nmap":
                severity = get_nmap_severity(result.get('service', ''), result.get('port', 0))
            elif tool == "sqlmap":
                severity = get_sqlmap_severity(result.get('description', ''))
            elif tool == "zap":
                severity = get_zap_severity(result.get('risk', ''))
            else:
                severity = 'info'

            if severity not in severity_map:
                severity_map[severity] = []  # Initialiser une liste si elle n'existe pas
            severity_map[severity].append({
                "tool": tool,
                "description": result.get('description', 'Aucune description disponible'),
                "state": result.get('state', 'N/A'),
                "service": result.get('service', 'N/A'),
                "port": result.get('port', 'N/A'),
                "url": result.get('url', 'N/A'),
                "evidence": result.get('evidence', 'N/A'),
                "remediation": result.get('remediation', 'N/A'),
                "cve_id": result.get('cve_id', None)
            })

    # Vérifiez que toutes les entrées de severity_map sont des listes
    for key, value in severity_map.items():
        if not isinstance(value, list):
            severity_map[key] = []

    return severity_map

def parse_scan_results(output, tool):
    results = {
        "nmap": [],
        "zap": [],
        "sqlmap": [],
        "apisec": []
    }

    if tool == 'NMAP':
        lines = output.splitlines()
        protocols = []
        for line in lines:
            if "open" in line and "/" in line:
                parts = line.split()
                if len(parts) >= 3:
                    port_protocol = parts[0].split('/')
                    port = int(port_protocol[0])
                    protocol = port_protocol[1]
                    state = parts[1]
                    service = parts[2]
                    protocols.append({
                        "port": port,
                        "protocol": protocol,
                        "state": state,
                        "service": service
                    })
        if protocols:
            results["nmap"].append({"protocols": protocols})

    elif tool == 'SQLMAP':
        if "vulnerable" in output.lower():
            vulnerabilities = output.split("vulnerable")[1:]
            for vuln in vulnerabilities:
                results["sqlmap"].append({
                    "risk": "high",
                    "description": vuln.strip(),
                    "parameter": "non précisé",
                    "evidence": "Payload détecté dans la requête",
                    "remediation": "Utilisez des requêtes préparées et échappez les entrées utilisateur."
                })

    elif tool == 'ZAP':
        lines = output.lower().splitlines()
        for line in lines:
            if "alert" in line or "xss" in line:
                results["zap"].append({
                    "risk": "high",
                    "alert": "XSS détectée",
                    "url": "inconnue",
                    "evidence": "Payload détecté dans la réponse",
                    "remediation": "Validez et échappez les entrées utilisateur."
                })

    # Vérifiez que chaque clé contient une liste
    for key, value in results.items():
        if not isinstance(value, list):
            results[key] = []

    return results


def launch_scan(request):
    if request.method == 'POST':
        form = ScanForm(request.POST)
        if form.is_valid():
            scan = form.save(commit=False)
            scan.status = 'in_progress'
            scan.start_time = now()
            scan.save()

            tool = scan.tool
            project = scan.project
            target_url = project.url

            if not target_url:
                messages.error(request, "Le projet sélectionné n'a pas d'URL définie.")
                return redirect('vulnerabilities')

            try:
                if tool == 'ZAP':
                    zap = ZAPv2(
                        apikey='620tjnb5od0ef8tep7n78usun',
                        proxies={'http': 'http://zap:8086', 'https': 'http://zap:8086'}
                    )

                    # Vérifier la disponibilité de l'API ZAP
                    for i in range(30):
                        try:
                            if zap.core.version:
                                break
                        except:
                            time.sleep(2)
                    else:
                        raise Exception("L'API ZAP n'est pas disponible.")

                    # Lancer le scan ZAP
                    zap.urlopen(target_url)
                    time.sleep(2)
                    scan_id = zap.ascan.scan(target_url)
                    while int(zap.ascan.status(scan_id)) < 100:
                        time.sleep(5)

                    # Récupérer les alertes ZAP
                    alerts = zap.core.alerts(baseurl=target_url)
                    for alert in alerts:
                        name = alert.get('alert', 'Vulnérabilité détectée')
                        description = alert.get('description', 'Aucune description disponible.')
                        severity = alert.get('risk', 'Medium')
                        remediation = alert.get('solution', 'Aucune solution disponible.')
                        parameter = alert.get('param', 'Non spécifié')
                        evidence = alert.get('evidence', 'Aucune preuve disponible.')

                        Vulnerability.objects.create(
                            scan=scan,
                            name=name,
                            description=description,
                            severity=severity,
                            target_url=alert.get('url', target_url),
                            remediation=remediation,
                            parameter=parameter,
                            evidence=evidence,
                            cve_id=alert.get('cweid', ''),
                            status='open',
                            discovered_at=now()
                        )

                elif tool == 'SQLMAP':
                    # Lancer SQLMap
                    command = ['sqlmap', '-u', target_url, '--batch', '--output-dir=/tmp', '--flush-session']
                    result = subprocess.run(command, capture_output=True, text=True)
                    output = result.stdout.lower()

                    # Analyser les résultats SQLMap
                    if "is vulnerable" in output:
                        parameter = None
                        technique = None
                        dbms = None
                        request_type = None

                        if "parameter:" in output:
                            parameter = output.split("parameter:")[1].split("\n")[0].strip()
                        if "technique:" in output:
                            technique = output.split("technique:")[1].split("\n")[0].strip()
                        if "dbms:" in output:
                            dbms = output.split("dbms:")[1].split("\n")[0].strip()
                        if "type:" in output:
                            request_type = output.split("type:")[1].split("\n")[0].strip()

                        name = "SQL Injection"
                        description = f"SQL Injection détectée sur le paramètre '{parameter}' en utilisant la technique '{technique}'. SGBD détecté : {dbms}."
                        remediation = "Utilisez des requêtes préparées et échappez les entrées utilisateur."

                        Vulnerability.objects.create(
                            scan=scan,
                            name=name,
                            description=description,
                            severity="High",
                            target_url=target_url,
                            parameter=parameter,
                            remediation=remediation,
                            evidence=f"Technique: {technique}, SGBD: {dbms}, Type de requête: {request_type}",
                            cve_id=None,
                            status='open',
                            discovered_at=now()
                        )

                elif tool == 'NMAP':
                    # Lancer Nmap
                    command = ['nmap', '-sV', '-O', '-Pn', '-T4', project.ip_address]
                    result = subprocess.run(command, capture_output=True, text=True, timeout=400)
                    output = result.stdout
                    lines = output.splitlines()

                    # Analyser les résultats Nmap
                    for line in lines:
                        if "open" in line and "/" in line:
                            parts = line.split()
                            if len(parts) >= 3:
                                port_protocol = parts[0].split('/')
                                port = int(port_protocol[0])
                                protocol = port_protocol[1]
                                state = parts[1]
                                service = parts[2]
                                version = " ".join(parts[3:]) if len(parts) > 3 else None

                                name = f"Port {port} - {service}"
                                description = f"Port {port} ({service}) est {state}."
                                remediation = "Vérifiez la configuration du service."

                                Vulnerability.objects.create(
                                    scan=scan,
                                    name=name,
                                    description=description,
                                    severity="Medium",
                                    target_url=project.url,
                                    parameter=None,
                                    remediation=remediation,
                                    evidence=f"Protocole: {protocol}, État: {state}, Service: {service}, Version: {version}",
                                    cve_id=None,
                                    status='open',
                                    discovered_at=now()
                                )

                # Mettre à jour le statut du scan
                scan.status = 'completed'
                scan.end_time = now()
                scan.duration = (scan.end_time - scan.start_time).total_seconds()
                scan.save()
                messages.success(request, f"Scan {tool} terminé avec succès.")

            except Exception as e:
                # Gestion des erreurs
                scan.status = 'failed'
                scan.save()
                messages.error(request, f"Erreur lors de l'exécution du scan {tool} : {str(e)}")
        else:
            messages.error(request, "Le formulaire est invalide.")
    return redirect('vulnerabilities')



@login_required
def vulnerabilities_view(request):
    # Get base queryset
    scans = Scan.objects.all().order_by('-created_at')
    
    # Apply filters
    filters = Q()
    
    # Project filter
    project_id = request.GET.get('project')
    if project_id:
        filters &= Q(project_id=project_id)
    
    # Severity filter
    severity = request.GET.get('severity')
    if severity:
        filters &= Q(vulnerabilities__severity=severity)
    
    # Status filter
    status = request.GET.get('status')
    if status:
        filters &= Q(status=status)
    
    # Date range filter
    from_date = request.GET.get('from')
    to_date = request.GET.get('to')
    if from_date:
        try:
            from_date = datetime.strptime(from_date, '%Y-%m-%d')
            filters &= Q(created_at__gte=from_date)
        except ValueError:
            messages.error(request, "Format de date invalide pour la date de début")
    
    if to_date:
        try:
            to_date = datetime.strptime(to_date, '%Y-%m-%d')
            filters &= Q(created_at__lte=to_date)
        except ValueError:
            messages.error(request, "Format de date invalide pour la date de fin")
    
    # Search query
    query = request.GET.get('query')
    if query:
        filters &= (
            Q(name__icontains=query) |
            Q(project__name__icontains=query) |
            Q(tool__icontains=query) |
            Q(vulnerabilities__name__icontains=query)
        )
    
    # Apply filters to queryset
    scans = scans.filter(filters).distinct()
    
    # Annotate with vulnerability counts
    scans = scans.annotate(
        critical_count=Count('vulnerabilities', filter=Q(vulnerabilities__severity='critical')),
        high_count=Count('vulnerabilities', filter=Q(vulnerabilities__severity='high')),
        medium_count=Count('vulnerabilities', filter=Q(vulnerabilities__severity='medium')),
        low_count=Count('vulnerabilities', filter=Q(vulnerabilities__severity='low'))
    )
    
    # Add severities dictionary to each scan
    for scan in scans:
        scan.severities = {
            'critical': scan.critical_count,
            'high': scan.high_count,
            'medium': scan.medium_count,
            'low': scan.low_count
        }
    
    # Pagination
    page = request.GET.get('page', 1)
    paginator = Paginator(scans, 10)  # 10 items per page
    try:
        scans = paginator.page(page)
    except:
        scans = paginator.page(1)
    
    # Calculate total vulnerabilities for statistics
    total_vulns = Vulnerability.objects.count()
    critical_vulns = Vulnerability.objects.filter(severity='critical').count()
    high_vulns = Vulnerability.objects.filter(severity='high').count()
    medium_vulns = Vulnerability.objects.filter(severity='medium').count()
    low_vulns = Vulnerability.objects.filter(severity='low').count()
    
    # Calculate percentages
    critical_percentage = (critical_vulns / total_vulns * 100) if total_vulns > 0 else 0
    high_percentage = (high_vulns / total_vulns * 100) if total_vulns > 0 else 0
    medium_percentage = (medium_vulns / total_vulns * 100) if total_vulns > 0 else 0
    low_percentage = (low_vulns / total_vulns * 100) if total_vulns > 0 else 0
    
    context = {
        'scans': scans,
        'projects': Project.objects.all(),
        'critical_vulns': critical_vulns,
        'high_vulns': high_vulns,
        'medium_vulns': medium_vulns,
        'low_vulns': low_vulns,
        'critical_percentage': critical_percentage,
        'high_percentage': high_percentage,
        'medium_percentage': medium_percentage,
        'low_percentage': low_percentage,
        # Preserve filter values
        'selected_project': project_id,
        'selected_severity': severity,
        'selected_status': status,
        'from_date': from_date,
        'to_date': to_date,
        'query': query,
    }
    
    return render(request, 'admin/vulnerabilities.html', context)
def vulnerabilities_filter(request):
    if request.method == 'POST':
        data = json.loads(request.body)
        project = data.get('project')
        severity = data.get('severity')
        status = data.get('status')

        # Filtrer les vulnérabilités
        vulnerabilities = Vulnerability.objects.select_related('scan', 'scan__project').all()

        if project:
            vulnerabilities = vulnerabilities.filter(scan__project_id=project)
        if severity:
            vulnerabilities = vulnerabilities.filter(severity__iexact=severity)
        if status:
            vulnerabilities = vulnerabilities.filter(scan__status__iexact=status)

        # Préparer les données pour la réponse JSON
        results = []
        for vuln in vulnerabilities:
            results.append({
                'id': vuln.id,
                'name': vuln.name,
                'project': vuln.scan.project.name,
                'severity': vuln.severity,
                'severity_class': get_severity_class(vuln.severity),
                'status': vuln.scan.status,
                'status_class': get_status_class(vuln.scan.status),
                'target_url': vuln.target_url,
                'discovered_at': vuln.discovered_at.strftime('%d/%m/%Y'),
            })

        return JsonResponse({'vulnerabilities': results})


def relaunch_scan(request, scan_id):
    # Récupérer le scan existant
    original_scan = get_object_or_404(Scan, id=scan_id)
    try:
        # Créer un nouveau scan basé sur l'original
        new_scan = Scan.objects.create(
            name=f"{original_scan.name} (Relancé)",
            project=original_scan.project,
            tool=original_scan.tool,
            status='in_progress',
            start_time=now(),
        )

        # Relancer le scan en appelant la logique d'exécution
        if new_scan.tool == 'NMAP':
            command = ['nmap', '-sT', '-Pn', '-T4', '-F', new_scan.project.ip_address]
            result = subprocess.run(command, capture_output=True, text=True, timeout=400)
            output = result.stdout
            scan_results = parse_scan_results(output, 'NMAP')
        elif new_scan.tool == 'SQLMAP':
            command = ['sqlmap', '-u', new_scan.project.url, '--batch', '--output-dir=/tmp']
            result = subprocess.run(command, capture_output=True, text=True, timeout=400)
            output = result.stdout
            scan_results = parse_scan_results(output, 'SQLMAP')
        elif new_scan.tool == 'ZAP':
            zap = ZAPv2(apikey='620tjnb5od0ef8tep7n78usun', proxies={'http': 'http://localhost:8086'})
            zap.urlopen(new_scan.project.url)
            zap.spider.scan(new_scan.project.url)
            while int(zap.spider.status()) < 100:
                time.sleep(2)
            zap.ascan.scan(new_scan.project.url)
            while int(zap.ascan.status()) < 100:
                time.sleep(5)
            alerts = zap.core.alerts(baseurl=new_scan.project.url)
            scan_results = {"zap": alerts}
        else:
            messages.error(request, "Outil de scan non pris en charge.")
            return redirect('vulnerabilities')

        # Traiter les résultats et mettre à jour le nouveau scan
        severity_map = classify_scan_findings(scan_results)
        for severity, vulns in severity_map.items():
            for vuln_data in vulns:
                Vulnerability.objects.create(
                    scan=new_scan,
                    name=vuln_data.get('description', 'Vulnérabilité détectée'),
                    description=vuln_data.get('description', ''),
                    severity=severity,
                    target_url=new_scan.project.url,
                    remediation=vuln_data.get('remediation', ''),
                    cve_id=vuln_data.get('cve_id', None),
                    status='open',
                    discovered_at=now()
                )
        new_scan.status = 'completed'
        new_scan.end_time = now()
        new_scan.duration = (new_scan.end_time - new_scan.start_time).total_seconds()
        new_scan.save()
        messages.success(request, f"Le scan {new_scan.name} a été relancé avec succès.")
    except Exception as e:
        new_scan.status = 'failed'
        new_scan.save()
        messages.error(request, f"Erreur lors de la relance du scan : {str(e)}")
    return redirect('vulnerabilities')


def export_vulnerabilities(request):
    format = request.GET.get('format', 'json')
    vulnerabilities = Vulnerability.objects.select_related('scan', 'scan__project').all()

    if format == 'json':
        data = list(vulnerabilities.values())
        return JsonResponse(data, safe=False)

    elif format == 'csv':
        response = HttpResponse(content_type='text/csv')
        response['Content-Disposition'] = 'attachment; filename="vulnerabilities.csv"'
        writer = csv.writer(response)
        writer.writerow(['ID', 'Nom', 'Projet', 'Sévérité', 'Statut', 'URL cible', 'Découvert le'])
        for vuln in vulnerabilities:
            writer.writerow([
                vuln.id, vuln.name, vuln.scan.project.name, vuln.severity,
                vuln.status, vuln.target_url, vuln.discovered_at
            ])
        return response

    else:
        return JsonResponse({'error': 'Format non pris en charge'}, status=400)



def generate_scan_report(request, scan_id):
    scan = get_object_or_404(Scan, id=scan_id)
    project = scan.project
    vulnerabilities = scan.vulnerabilities.all()

    response = HttpResponse(content_type='application/pdf')
    response['Content-Disposition'] = f'attachment; filename="rapport_scan_{scan.id}.pdf"'

    doc = SimpleDocTemplate(response, pagesize=letter, rightMargin=36, leftMargin=36, topMargin=72, bottomMargin=36)
    elements = []
    styles = getSampleStyleSheet()

    # Style personnalisé pour le titre
    title_style = ParagraphStyle(name='TitleStyle', fontSize=24, leading=28, alignment=1, textColor=colors.HexColor("#FFFFFF"), spaceAfter=20)
    subtitle_style = ParagraphStyle(name='SubtitleStyle', fontSize=14, leading=18, alignment=0, textColor=colors.HexColor("#003366"), spaceAfter=10)
    body_style = ParagraphStyle(name='BodyText', parent=styles['Normal'], fontSize=10, leading=14)
    footer_style = ParagraphStyle(name='FooterStyle', fontSize=9, alignment=1, textColor=colors.HexColor("#FFFFFF"), backColor=colors.HexColor("#003366"), spaceBefore=10)

    # Fond bleu
    elements.append(Spacer(1, 12))

    # Informations du scan
    scan_info = f"""
    <b>Nom du Scan :</b> {scan.name}<br/>
    <b>Projet :</b> {project.name}<br/>
    <b>Outil utilisé :</b> {scan.tool}<br/>
    <b>Statut :</b> {scan.status}<br/>
    <b>Durée :</b> {f"{scan.duration:.2f} secondes" if scan.duration else "N/A"}<br/>
    """
    elements.append(Paragraph(scan_info, body_style))
    elements.append(Spacer(1, 12))

    # Titre principal centré et souligné
    title = Paragraph("<u>Rapport de Scan</u>", title_style)
    elements.append(title)
    elements.append(Spacer(1, 12))

    # Résultats du Scan en fonction de l'outil
    if scan.tool == 'NMAP':
        elements.append(Paragraph("Résultats du Scan NMAP", subtitle_style))
        nmap_details = f"""
        <b>Adresse IP cible :</b> {project.ip_address}<br/>
        <b>Ports ouverts :</b> Liste des ports ouverts et services sur {project.ip_address}.<br/>
        """
        elements.append(Paragraph(nmap_details, body_style))

        # Ajouter les vulnérabilités de Nmap
        for vuln in vulnerabilities:
            if vuln.port:
                nmap_vuln_details = f"""
                <b>Port :</b> {vuln.port}<br/>
                <b>Protocole :</b> {vuln.protocol}<br/>
                <b>Service :</b> {vuln.service}<br/>
                <b>Version :</b> {vuln.version}<br/>
                <b>Gravité :</b> {vuln.severity}<br/>
                """
                elements.append(Paragraph(nmap_vuln_details, body_style))

    elif scan.tool == 'SQLMAP':
        elements.append(Paragraph("Résultats du Scan SQLMAP", subtitle_style))
        sqlmap_details = f"""
        <b>Paramètre vulnérable :</b> {', '.join([vuln.parameter for vuln in vulnerabilities if vuln.parameter])}<br/>
        <b>DBMS détecté :</b> {', '.join([vuln.dbms for vuln in vulnerabilities if vuln.dbms])}<br/>
        <b>Technique utilisée :</b> {', '.join([vuln.technique for vuln in vulnerabilities if vuln.technique])}<br/>
        """
        elements.append(Paragraph(sqlmap_details, body_style))

        # Ajouter les vulnérabilités spécifiques à SQLMap
        for vuln in vulnerabilities:
            sqlmap_vuln_details = f"""
            <b>Paramètre :</b> {vuln.parameter or 'Non spécifié'}<br/>
            <b>Technique :</b> {vuln.technique or 'Non spécifiée'}<br/>
            <b>SGBD détecté :</b> {vuln.dbms or 'Non spécifié'}<br/>
            """
            elements.append(Paragraph(sqlmap_vuln_details, body_style))

    elif scan.tool == 'ZAP':
        elements.append(Paragraph("Résultats du Scan ZAP", subtitle_style))
        zap_details = f"""
        <b>Alertes :</b><br/>
        <i>Liste des vulnérabilités détectées par ZAP.</i><br/>
        """
        elements.append(Paragraph(zap_details, body_style))

        # Ajouter les vulnérabilités de ZAP
        for vuln in vulnerabilities:
            zap_vuln_details = f"""
            <b>Alerte :</b> {vuln.alert or 'Non spécifiée'}<br/>
            <b>Risque :</b> {vuln.risk or 'Non spécifié'}<br/>
            <b>Confiance :</b> {vuln.confidence or 'Non spécifiée'}<br/>
            <b>Preuve :</b> {vuln.evidence or 'Non spécifiée'}<br/>
            """
            elements.append(Paragraph(zap_vuln_details, body_style))

    else:
        elements.append(Paragraph("Aucun outil de scan spécifié.", body_style))

    # Pied de page
    elements.append(PageBreak())
    footer = f"""
    <b>EthicalPulse</b> - Rapport généré automatiquement<br/>
    <b>Date :</b> {now().strftime('%d/%m/%Y %H:%M:%S')}<br/>
    """
    elements.append(Paragraph(footer, footer_style))

    # Générer le PDF
    doc.build(elements)
    return response


def delete_scan(request, scan_id):
    """
    Supprime un scan spécifique.
    """
    scan = get_object_or_404(Scan, id=scan_id)
    scan.delete()
    messages.success(request, f"Le scan #{scan_id} a été supprimé avec succès.")
    return redirect('vulnerabilities')

class BaseViewMixin:
    def get_context_data(self, **kwargs):
        context = super().get_context_data(**kwargs)
        context.update(get_base_context(self.request))
        return context

def vuln_view(request):
    # Récupérer les scans avec les filtres
    scans = Scan.objects.all()  # Ajoute ici tes filtres si nécessaire

    # Pagination : 15 éléments par page
    paginator = Paginator(scans, 15)
    page_number = request.GET.get('page')
    page_obj = paginator.get_page(page_number)

    return render(request, 'vuln_view.html', {'scans': page_obj})

